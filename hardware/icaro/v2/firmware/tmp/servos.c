/*-------------------------------------------------------------------------
	servo.c  LIBRARY FOR CONTROLLING UP TO 18 SERVO WITH PINGUINO 18F2550
    =====================================================================

             Version: 1.0
			 copyright  JesÃºs Carmona Esteban
			 Date: 28/7/2010

    This library is free software; you can redistribute it and/or
    modify it under the terms of the GNU Lesser General Public
    License as published by the Free Software Foundation; either
    version 2.1 of the License, or (at your option) any later version.

    This library is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
    Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public
    License along with this library; if not, write to the Free Software
    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
-------------------------------------------------------------------------*/

// This library is optimized for Pinguino 18F2550 
// it allows to drive up to 18 servos simultaneously. So, all 
// Pinguino 18F2550 pins can be configured as servo drivers.
//
// NOTES: 
// - Xtal must be 20 Mhz. Thus the resulting clock after PLL will be
//   of 48Mhz => 12 MIPS (Fosc/4).
// - This library allows 250 positions for a servo, corresponding 
//   1 to 1000 usecs, and 250 to 2000 usec aprox.
// - All servos are automatically refreshed by PIC in a parallel way.
// 
// 
// -----------------------------------------------------------------------------

#define SERVOSLIBRARY 1


// Max and Min values allowed:
#define SERVOMAX 250
#define SERVOMIN   1


//library internal variables:
uchar phase=0;
uchar needreordering=0;


uchar timingindex;
uchar timedivision=0;
uchar loopvar;
uchar timings[4][18];  
uchar activatedservos[3]={0x00,0x00,0x00};
// For referencing masks in the previous array.
#define MaskPort_B  0
#define MaskPort_C  1
#define MaskPort_A  2
#define timevalue   3

uchar servovalues[18]; // Entry table for values sets for every pin-servo.

//Masks table:
//uchar servomasks[8]={ 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80 };
// The following masks are in this order : PORTB (8 bits), PORTC (5bits) & PORTA (5bits)
const uchar servomasks[18]={0X01,0x02,0x04,0x08,0x10,0x20,0x40,0x80,0x40,0x80,0x01,0x02,0x04,0x01,0x02,0x04,0x08,0x20};


 
void servos_init()
{
	unsigned char a;

	for(a=0;a<18;a++) servovalues[a]=255;


	TMR1H=0xFF;
	TMR1L=0x00;
	// timer 1 prescaler 1 source is internal oscillator
	T1CON=0x01;
	// enable interrupt for timer1 in register PIE1
	PIE1bits.TMR1IE=1;
	// enable peripheral interrupt
	INTCONbits.PEIE=1;
	// global enable interrupt
	INTCONbits.GIE=1;
	// now the first interrupt will be generated by timer2 after 9 ms.
}


static void ServosPulseDown()
{
	timingindex = 0;
	
	for(timedivision=0;timedivision < 251;timedivision++){
		if (timings[timevalue][timingindex] == timedivision){
//			PORTB = PORTB ^ timings[MaskPort_B][timingindex];
			PORTC = PORTC ^ timings[MaskPort_C][timingindex];
			PORTA = PORTA ^ timings[MaskPort_A][timingindex];
			timingindex++;
		}
		// the following routine adds the requiered delay for every tick of timedivision, so every timedivision last 4 usec.
        __asm 
			movlw 20
			movwf _loopvar
		bucle:
			NOP
			decfsz _loopvar,1
			goto bucle
		__endasm;
	}
}

static void ServosPulseUp()
{
// This function starts up pulses for all activated servos.
//	PORTB = activatedservos[MaskPort_B] & 0xFF;
	PORTC = activatedservos[MaskPort_C] & 0xFF;
	PORTA = activatedservos[MaskPort_A] & 0xFF;	
}


static void SortServoTimings()
{
// This funtion analyses servovalues table and creates and ordered table(timings)
// from smaller to bigger of all the values, asociating to each 
// position of the table the servos that matches that timing.

	uchar s,t,totalservos,numservos;
	uchar mascaratotal[3]={0x00,0x00,0x00};
	
	// inicializamos la tabla:
	for(t=0;t<18;t++){
		timings[timevalue][t]=255;
//		timings[MaskPort_B][t]=0x00;
		timings[MaskPort_C][t]=0x00;
		timings[MaskPort_A][t]=0x00;
	}
	
	totalservos=0;
	t=0;
	while(totalservos<18) {
		numservos=1;
		for(s=0;s<18;s++) { 
			// Case that we are reviewing PORTB servos:
			if (s<8){
				if (servomasks[s] & mascaratotal[MaskPort_B] & activatedservos[MaskPort_B]){
				}
				else if (servovalues[s] < timings[timevalue][t]){
					timings[timevalue][t]=servovalues[s];
//					timings[MaskPort_B][t]=servomasks[s];
					timings[MaskPort_C][t]=0x00;
					timings[MaskPort_A][t]=0x00;
					numservos=1;
				}
				else if (servovalues[s] == timings[timevalue][t]){
//					timings[MaskPort_B][t] |= servomasks[s];
					numservos++;
				}
			}
			// Case that we are reviewing PORTA servos:
			else if (s>12){
				if (servomasks[s] & mascaratotal[MaskPort_A] & activatedservos[MaskPort_A]){
				}
				else if (servovalues[s] < timings[timevalue][t]){
					timings[timevalue][t]=servovalues[s];
					//timings[MaskPort_B][t]=0x00;
					timings[MaskPort_C][t]=0x00;
					timings[MaskPort_A][t]=servomasks[s];
					numservos=1;
				}
				else if (servovalues[s] == timings[timevalue][t]){
					timings[MaskPort_A][t] |= servomasks[s];
					numservos++;
				}
			}
			// Case that we are reviewing PORTC servos:
			else {
				if (servomasks[s] & mascaratotal[MaskPort_C] & activatedservos[MaskPort_C]){ 
				}
				else if (servovalues[s] < timings[timevalue][t]){
					timings[timevalue][t]=servovalues[s];
					//timings[MaskPort_B][t]=0x00;
					timings[MaskPort_C][t]=servomasks[s];
					timings[MaskPort_A][t]=0x00;
					numservos=1;
				}
				else if (servovalues[s] == timings [timevalue][t]){
					timings[MaskPort_C][t] |= servomasks[s];
					numservos++;
				}
			}				
			
		}
		//mascaratotal[MaskPort_B] |= timings[MaskPort_B][t];
		mascaratotal[MaskPort_C] |= timings[MaskPort_C][t];
		mascaratotal[MaskPort_A] |= timings[MaskPort_A][t];
		totalservos += numservos;
		t++;
	
	}
	needreordering=0;  // This indicates that servo timings is ordered.	
}	


	
void ServoAttach(uchar pin)
{
	if(pin>=18) return;

	if(pin<8){
		activatedservos[MaskPort_B] = activatedservos[MaskPort_B] | servomasks[pin];  // list pin as servo driver.
		TRISB = TRISB & (255 - servomasks[pin]); // set as output pin
	} else if (pin>12) {
		activatedservos[MaskPort_A] = activatedservos[MaskPort_A] | servomasks[pin];  // list pin as servo driver.
		TRISA = TRISA & (255 - servomasks[pin]); // set as output pin
	} else {
		activatedservos[MaskPort_C] = activatedservos[MaskPort_C] | servomasks[pin];  // list pin as servo driver.
		TRISC = TRISC & (255 - servomasks[pin]); // set as output pin
	}
	
}

void ServoDetach(uchar pin)
{
	if(pin>=18) return;

	if(pin<8){
		activatedservos[MaskPort_B] = activatedservos[MaskPort_B] ^ servomasks[pin];
	} else if (pin>12) {
		activatedservos[MaskPort_A] = activatedservos[MaskPort_A] ^ servomasks[pin];
	} else {
		activatedservos[MaskPort_C] = activatedservos[MaskPort_C] ^ servomasks[pin];
	}
	
}

void ServoWrite(uchar servo, uchar value)
{
	if(servo>=18)        // test if numservo is valid
		return;
	
	if(value<SERVOMIN)  //  1 = 1000 useg pulse
		value=SERVOMIN;
	if(value>SERVOMAX) // 250 = 2000 useg pulse
		value=SERVOMAX;
	servovalues[servo]=value;
	
	needreordering=1;  // This indicates servo timings must be reordered.
}


unsigned char ServoRead(uchar servo)
{
	if(servo>=18)        // test if numservo is valid
		return 0;
	return servovalues[servo];
}


void ServoMinimumPulse(uchar servo)
{
	if(servo>=18)        // test if numservo is valid
		return;
	
	servovalues[servo]=SERVOMIN;  //  1 = 1000 useg pulse

	needreordering=1;  // This indicates servo timings must be reordered.
}


void ServoMaximumPulse(uchar servo)
{
	if(servo>=18)        // test if numservo is valid
		return;
	
	servovalues[servo]=SERVOMAX;  //  250 = 2000 useg pulse

	needreordering=1;  // This indicates servo timings must be reordered.
}



//interrupt handler that handles servos
void servos_interrupt(void)
{
	if (PIR1bits.TMR1IF) {
		PIR1bits.TMR1IF=0;
		T1CON=0x00;
		if (phase) {
		//case before 1st ms:
			ServosPulseUp();
			// Load at TMR1 54159d(also 0xFFFF - 12000d (- 54usec for adjustments)).
			TMR1H= 0xf2; //0xd3;
			TMR1L= 0x30;//ff; //0x8f;
			// timer 1 prescaler 1 source is internal oscillator Fosc/4 (CPU clock or Fosc=48Mhz).
			T1CON=1;
			phase = 0;
		} 
		else {
		//case before 2nd ms:
			//The following call takes 1 ms aprox.:
			ServosPulseDown();
			// Now it takes place a 18 ms delay, after that a interrupt will be generated.
			// Loading at TMR1 11535d (que es: 0xFFFF - (4,5 x 12000(duracion 1ms)) = 0x2D0F => a 4,5 ms) 
			// This 4,5 x 4 (with preescaler x 4) we get 18 ms delay.
			TMR1H= 0x2d;//0x2d;
			TMR1L= 0x0f;
			// timer 1 prescaler 1 source is internal oscillator Fosc/4 (recordemos que Fosc=48Mhz).
			if (needreordering)	
				SortServoTimings();  // This takes more than 1 ms, but it's call only if needed.
			T1CON= ( 1 | 2 << 4 ) ; // activate timer1 and prescaler = 1:4
			phase = 1;  //This indicates that after next interrupt it will start the servos cycle.
		} 
	}
	return;
}

